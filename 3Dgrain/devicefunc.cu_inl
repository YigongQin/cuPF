__inline__ __device__ void 
G2L_3D(int pf_C, int &i, int &j, int &k, int &PF_id, int fnx, int fny, int fnz){

  k = pf_C/(fnx*fny);
  int pf_C_z=pf_C-k*fnx*fny; 
  j = pf_C_z/fnx;
  i = pf_C_z-j*fnx;

}


__inline__ __device__ void 
G2L_4D(int C, int &i, int &j, int &k, int &PF_id, int fnx, int fny, int fnz){

  PF_id = C/(fnx*fny*fnz);
  int pf_C = C - PF_id*fnx*fny*fnz;  // local C in every PF
  k = pf_C/(fnx*fny);
  int pf_C_z=pf_C-k*fnx*fny; 
  j = pf_C_z/fnx;
  i = pf_C_z-j*fnx;

}

__inline__ __device__ int 
L2G_4D(int i, int j, int k, int pf, int fnx, int fny, int fnz){

    return i + j*fnx + k*fnx*fny + pf*fnx*fny*fnz;

}


__inline__ __device__ float
kine_ani(float ux, float uy, float uz, float cosa, float sina, float cosb, float sinb){

   float a_s = 1.0f + 3.0f*cP.kin_delta;
   float epsilon = -4.0f*cP.kin_delta/a_s;
   float ux2 = cosa*cosb*ux  + sina*uy + cosa*sinb*uz;
         ux2 = ux2*ux2;
   float uy2 = -sina*cosb*ux + cosa*uy - sina*sinb*uz;
         uy2 = uy2*uy2;      
   float uz2 = -sinb*ux      + 0       + cosb*uz;
         uz2 = uz2*uz2;
   float MAG_sq = (ux2 + uy2 + uz2);
   float MAG_sq2= MAG_sq*MAG_sq;
   if (MAG_sq > cP.eps){
         return a_s*( 1.0f + epsilon*(ux2*ux2 + uy2*uy2 + uz2*uz2) / MAG_sq2);}
   else {return 1.0f;}
}